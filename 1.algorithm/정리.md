# 알고리즘 관련 정리

## DP

- 조건

  - 최적 부분 구조
    - 부분 문제들의 최적의 답을 이용하면 전체 문제의 최적의 답이 구해지는 구조
  - 중복되는 부분 문제

- 활용

  - 한 번 계산한 결과를 재활용하는 것
  - Memoization
    - 하향식 방법
    - 딕셔너리 cache를 활용하여 재귀로 구현
  - Tabulation
    - 상향식 방법
    - 상향식이기 때문에 문제를 푸는 데 필요없는 부분도 미리 계산하는 경우도 있다. 그래서 Memoization에 비해 약간의 비효율 발생할 수도 있다

- 예시

  - ```python
    def max_profit(stock_list):
        result = stock_list[1] - stock_list[0]
        min_buy_value = stock_list[0]
        
        for i in range(len(stock_list)-1):
            if stock_list[i] < min_buy_value:
                min_buy_value = stock_list[i]
            
            profit = stock_list[i+1] - min_buy_value
            if profit > result:
                result = profit
                
        return result
    
    
    # 테스트
    print(max_profit([7, 1, 5, 3, 6, 4]))
    print(max_profit([7, 6, 4, 3, 1]))
    print(max_profit([11, 13, 9, 13, 20, 14, 19, 12, 19, 13]))
    print(max_profit([12, 4, 11, 18, 17, 19, 1, 19, 14, 13, 7, 15, 10, 1, 3, 6]))
    ```

  - ```python
    def sublist_max(profits):
        result = profits[0]
        cur_max = profits[0]
        
        for i in range(1, len(profits)):
            cur_max = max(cur_max + profits[i], profits[i])
            result = max(result, cur_max)
                    
        return result
    
    
    # 테스트
    print(sublist_max([7, -3, 4, -8]))
    print(sublist_max([-2, -3, 4, -1, -2, 1, 5, -3, -1]))
    ```

  - ```python
    def trapping_rain(buildings):
        width = len(buildings)
        lefts = [0 for _ in range(width)]
        rights = [0 for _ in range(width)]
        
        for i in range(1, width):
            if lefts[i-1] < buildings[i-1]:
                lefts[i] = buildings[i-1]
            else:
                lefts[i] = lefts[i-1]
            
        for i in range(width-2, -1, -1):
            if rights[i+1] < buildings[i+1]:
                rights[i] = buildings[i+1]
            else:
                rights[i] = rights[i+1]
        
        # for left in lefts:
        #     print(left, end=' ')
            
        # print()
        
        # for right in rights:
        #     print(right, end=' ')
        
        # print()
        
        waters = 0    
        for i in range(1, width-1):
            if buildings[i] < lefts[i] and buildings[i] < rights[i]:
                waters += min(lefts[i], rights[i]) - buildings[i]
                
        return waters
    
        
    # 테스트
    print(trapping_rain([3, 0, 0, 2, 0, 4]))
    print(trapping_rain([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]))
    ```



## Greedy Algorithm

- 최적의 답을 구할 수 있는 조건
  - 최적 부분 구조
  - 탐욕적 선택 속성
    - 최적 부분 구조와 다른 점은 시점에 있다. 탐욕적 선택 속성은 지금 당장 목표를 달성하기 위해 탐욕적으로 선택하면, 그 선택이 결과적으로도 최선의 선택일 때를 의미한다



## Sorting

### Merge Sort

```python
## 모범 답안
def merge(list1, list2):
    i = 0
    j = 0

    # 정렬된 항목들을 담을 리스트
    merged_list = []

    # list1과 list2를 돌면서 merged_list에 항목 정렬
    while i < len(list1) and j < len(list2):
        if list1[i] > list2[j]:
            merged_list.append(list2[j])
            j += 1
        else:
            merged_list.append(list1[i])
            i += 1

    # list2에 남은 항목이 있으면 정렬 리스트에 추가
    if i == len(list1):
        merged_list += list2[j:]

    # list1에 남은 항목이 있으면 정렬 리스트에 추가
    elif j == len(list2):
        merged_list += list1[i:]

    return merged_list


def merge_sort(my_list):
    # base case
    if len(my_list) < 2:
        return my_list

    # my_list를 반씩 나눈다(divide)
    left_half = my_list[:len(my_list)//2]    # 왼쪽 반
    right_half = my_list[len(my_list)//2:]   # 오른쪽 반

    # merge_sort 함수를 재귀적으로 호출하여 부분 문제 해결(conquer)하고,
    # merge 함수로 정렬된 두 리스트를 합쳐(combine)준다
    return merge(merge_sort(left_half), merge_sort(right_half))
```

```python
## 내가 짠 것. merge 과정과 쪼개는 과정을 합쳐놔서 가독성 떨어짐
def merge(list1, list2):
    if len(list1) == 0:
        return list2
    elif len(list2) == 0:
        return list1
    
    mid_list1 = len(list1) // 2
    mid_list2 = len(list2) // 2
    
    sorted_list1 = merge(list1[0:mid_list1], list1[mid_list1:])
    sorted_list2 = merge(list2[0:mid_list2], list2[mid_list2:])
    
    result_list = []
    while True:
        if len(sorted_list1) == 0:
            result_list += sorted_list2
            break
        elif len(sorted_list2) == 0:
            result_list += sorted_list1
            break
        
        if sorted_list1[0] <= sorted_list2[0]:
            result_list.append(sorted_list1.pop(0))
        else:
            result_list.append(sorted_list2.pop(0))
            
    return result_list

# 합병 정렬
def merge_sort(my_list):
    mid = len(my_list) // 2
    return merge(my_list[0:mid], my_list[mid:])
```



### Quick Sort

```python
# 두 요소의 위치를 바꿔주는 helper function
def swap_elements(my_list, index1, index2):
    my_list[index1], my_list[index2] = my_list[index2], my_list[index1]
    return


# 퀵 정렬에서 사용되는 partition 함수
def partition(my_list, start, end):
    p = end
    b = start
    i = start
    
    while i != p:
        if my_list[i] > my_list[p]:
            i += 1
            continue
        else:
            swap_elements(my_list, b, i)
            i += 1
            b += 1
            
    swap_elements(my_list, b, p)
    
    return b


def quicksort(my_list, start=0, end=None):
    if end == None:
        end = len(my_list) - 1
    
    if start == end:
        return
    
    p = partition(my_list, start, end)
    quicksort(my_list, start, p-1)
    quicksort(my_list, p, end)
    
    return
```

